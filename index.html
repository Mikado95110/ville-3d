<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Ville 3D</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
<script>
  let camera, scene, renderer, controls;
  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
  let velocity = new THREE.Vector3();
  let clock = new THREE.Clock();

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.y = 10;

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());

    scene.add(controls.getObject());

    const light = new THREE.HemisphereLight(0xffffff, 0x444444);
    light.position.set(0, 200, 0);
    scene.add(light);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshPhongMaterial({ color: 0x999999 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Générer des bâtiments
    for (let i = 0; i < 200; i++) {
      const building = new THREE.Mesh(
        new THREE.BoxGeometry(10, Math.random() * 50 + 10, 10),
        new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff })
      );
      building.position.set(
        (Math.random() - 0.5) * 800,
        building.geometry.parameters.height / 2,
        (Math.random() - 0.5) * 800
      );
      scene.add(building);
    }

    // Contrôles clavier
    const onKeyDown = (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp': moveForward = true; break;
        case 'KeyS': case 'ArrowDown': moveBackward = true; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
        case 'KeyD': case 'ArrowRight': moveRight = true; break;
      }
    };
    const onKeyUp = (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp': moveForward = false; break;
        case 'KeyS': case 'ArrowDown': moveBackward = false; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
        case 'KeyD': case 'ArrowRight': moveRight = false; break;
      }
    };
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    velocity.set(0, 0, 0);

    if (moveForward) velocity.z -= 400 * delta;
    if (moveBackward) velocity.z += 400 * delta;
    if (moveLeft) velocity.x -= 400 * delta;
    if (moveRight) velocity.x += 400 * delta;

    controls.moveRight(velocity.x * delta);
    controls.moveForward(velocity.z * delta);

    renderer.render(scene, camera);
  }
</script>
</body>
</html>
